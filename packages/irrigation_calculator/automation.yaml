automation:
  # Keep the relay dropdown in sync with all available switch entities
  - id: irrigation_relay_dropdown_sync
    alias: "Irrigation – Sync relay dropdown (switches)"
    mode: single
    trigger:
      - platform: homeassistant
        event: start
      - platform: time_pattern
        minutes: "/15"
      - platform: event
        event_type: entity_registry_updated
    action:
      - variables:
          switches: "{{ states.switch | map(attribute='entity_id') | list }}"
      - service: input_select.set_options
        data:
          entity_id: input_select.irrigation_relay_entity
          options: "{{ switches }}"
      - condition: template
        value_template: >
          {% set cur = states('input_select.irrigation_relay_entity') %}
          {{ (switches | count) > 0 and cur not in switches }}
      - service: input_select.select_option
        data:
          entity_id: input_select.irrigation_relay_entity
          option: "{{ (states.switch | map(attribute='entity_id') | list)[0] }}"

  - id: irrigation_by_radiation
    alias: "Irrigation – Radiation Trigger"
    mode: single
    trigger:
      - platform: template
        value_template: >
          {% set phase = states('input_select.tomato_phase') %}
          {% set rad = states('sensor.radiation_since_irrigation') | float(0) %}
          {% set thresholds = {
              'Planting': states('input_number.threshold_rad_phase1') | float(0),
              'Fruit Set': states('input_number.threshold_rad_phase2') | float(0),
              'Ripening':  states('input_number.threshold_rad_phase3') | float(0)
            } %}
          {{ rad >= thresholds.get(phase, 1e9) }}
    condition:
      - condition: time
        after: "07:00:00"
        before: "19:00:00"
    action:
      - service: input_select.select_option
        data:
          entity_id: input_select.irrigation_last_reason
          option: "Radiation"
      - service: script.irrigation_run

  # Record the exact start time of any irrigation run
  - id: irrigation_record_last_run
    alias: "Irrigation – Record last run timestamp"
    mode: single
    trigger:
      - platform: state
        entity_id: script.irrigation_run
        to: "on"
    action:
      - service: input_datetime.set_datetime
        data:
          entity_id: input_datetime.irrigation_last_run
          date: "{{ now().strftime('%Y-%m-%d') }}"
          time: "{{ now().strftime('%H:%M:%S') }}"

  # Fallback trigger if no irrigation happened for the configured interval
  - id: irrigation_by_fallback
    alias: "Irrigation – Fallback Trigger"
    mode: single
    trigger:
      - platform: time_pattern
        minutes: "/1"
    condition:
      - condition: state
        entity_id: binary_sensor.irrigation_fallback_active
        state: "on"
      - condition: template
        value_template: >
          {% set last = as_timestamp(states('input_datetime.irrigation_last_run'), 0) %}
          {% set need = states('input_number.irrigation_fallback_minutes') | float(0) %}
          {% set ok_switch = states('input_select.irrigation_relay_entity') not in ['unknown','unavailable',''] %}
          {{ last > 0 and ok_switch and ( (as_timestamp(now()) - last) / 60 ) >= need and need >= 5 and need <= 240 }}
    action:
      - service: input_select.select_option
        data:
          entity_id: input_select.irrigation_last_reason
          option: "Fallback"
      - service: script.irrigation_run

  # Existing power monitoring automation kept as-is (no functional change)
  - id: irrigation_relais_power_monitor
    alias: "Monitor power consumption"
    mode: restart
    trigger:
      - id: start
        platform: state
        entity_id: script.irrigation_run
        to: "on"
      - id: end
        platform: state
        entity_id: script.irrigation_run
        to: "off"

    variables:
      selected_switch: "{{ states('input_select.irrigation_relay_entity') }}"
      fallback_power: >
        {% if selected_switch not in ['unknown','unavailable',''] %}
          {{ 'sensor.' ~ selected_switch.split('.')[1] ~ '_power' }}
        {% else %} {{ None }} {% endif %}
      power_entity: "{{ fallback_power }}"
      min_power: "{{ states('input_number.irrigation_relais1_power_min') | float(0) }}"
      max_power: "{{ states('input_number.irrigation_relais1_power_max') | float(0) }}"

    action:
      - choose:
          - conditions: "{{ trigger.id == 'start' }}"
            sequence:
              - wait_template: >
                  {% set st = states(power_entity) %}
                  {{ power_entity and st not in ['unknown','unavailable',''] and (st | float(0)) > 0 }}
                timeout: "00:00:15"
                continue_on_timeout: true
              - condition: template
                value_template: >
                  {% set st = states(power_entity) %}
                  {{ power_entity and st not in ['unknown','unavailable',''] }}
              - choose:
                  - conditions: "{{ (states(power_entity) | float(0)) <= min_power }}"
                    sequence:
                      - service: persistent_notification.create
                        data:
                          title: "{{ 'Power consumption ' ~ selected_switch ~ ' too low' }}"
                          message: >
                            Measured power ({{ states(power_entity) | float }} W)
                            is ≤ undercurrent threshold ({{ min_power }} W).
              - choose:
                  - conditions: "{{ (states(power_entity) | float(0)) >= max_power }}"
                    sequence:
                      - service: persistent_notification.create
                        data:
                          title: "{{ 'Power consumption ' ~ selected_switch ~ ' too high' }}"
                          message: >
                            Measured power ({{ states(power_entity) | float }} W)
                            exceeds over-current threshold ({{ max_power }} W).
          - conditions: "{{ trigger.id == 'end' }}"
            sequence:
              - delay: "00:00:02"
              - condition: template
                value_template: >
                  {% set st = states(power_entity) %}
                  {{ power_entity and st not in ['unknown','unavailable',''] and (st | float(0)) > 0 }}
              - service: persistent_notification.create
                data:
                  title: "{{ 'Power consumption ' ~ selected_switch ~ ' too high' }}"
                  message: >
                    Power after script end is {{ states(power_entity) | float }} W (should be 0 W).