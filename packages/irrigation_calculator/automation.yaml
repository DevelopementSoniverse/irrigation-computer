automation:
  # Keep the relay dropdown in sync with all available switch entities
  - id: irrigation_relay_dropdown_sync
    alias: "Irrigation – Sync relay dropdown (switches)"
    mode: single
    trigger:
      - platform: homeassistant
        event: start
      - platform: time_pattern
        minutes: "/15"
      - platform: event
        event_type: entity_registry_updated
    action:
      - variables:
          switches: "{{ states.switch | map(attribute='entity_id') | list }}"
      - service: input_select.set_options
        data:
          entity_id: input_select.irrigation_relay_entity
          options: "{{ switches }}"
      - condition: template
        value_template: >
          {% set cur = states('input_select.irrigation_relay_entity') %}
          {{ (switches | count) > 0 and cur not in switches }}
      - service: input_select.select_option
        data:
          entity_id: input_select.irrigation_relay_entity
          option: "{{ (states.switch | map(attribute='entity_id') | list)[0] }}"

  - id: irrigation_by_radiation
    alias: "Irrigation – Radiation Trigger"
    mode: single
    trigger:
      - platform: template
        value_template: >
          {% set phase = states('input_select.tomato_phase') %}
          {% set rad = states('sensor.radiation_since_irrigation') | float(0) %}
          {% set thresholds = {
              'Planting': states('input_number.threshold_rad_phase1') | float(0),
              'Fruit Set': states('input_number.threshold_rad_phase2') | float(0),
              'Ripening':  states('input_number.threshold_rad_phase3') | float(0)
            } %}
          {{ rad >= thresholds.get(phase, 1e9) }}
    condition:
      - condition: time
        after: "07:00:00"
        before: "19:00:00"
    action:
      - service: input_select.select_option
        data:
          entity_id: input_select.irrigation_last_reason
          option: "Radiation"
      - service: script.irrigation_run

  # Record the exact start time of any irrigation run
  - id: irrigation_record_last_run
    alias: "Irrigation – Record last run timestamp"
    mode: single
    trigger:
      - platform: state
        entity_id: script.irrigation_run
        to: "on"
    action:
      - service: input_datetime.set_datetime
        data:
          entity_id: input_datetime.irrigation_last_run
          date: "{{ now().strftime('%Y-%m-%d') }}"
          time: "{{ now().strftime('%H:%M:%S') }}"

  # Fallback trigger if no irrigation happened for the configured interval
  - id: irrigation_by_fallback
    alias: "Irrigation – Fallback Trigger"
    mode: single
    trigger:
      - platform: time_pattern
        minutes: "/1"
    condition:
      - condition: state
        entity_id: binary_sensor.irrigation_fallback_active
        state: "on"
      - condition: template
        value_template: >
          {% set last = as_timestamp(states('input_datetime.irrigation_last_run'), 0) %}
          {% set need = states('input_number.irrigation_fallback_minutes') | float(0) %}
          {% set ok_switch = states('input_select.irrigation_relay_entity') not in ['unknown','unavailable',''] %}
          {{ last > 0 and ok_switch and ( (as_timestamp(now()) - last) / 60 ) >= need and need >= 5 and need <= 240 }}
    action:
      - service: input_select.select_option
        data:
          entity_id: input_select.irrigation_last_reason
          option: "Fallback"
      - service: script.irrigation_run

  # Existing power monitoring automation kept as-is (no functional change)
  - id: irrigation_relais_power_monitor
    alias: "Monitor power consumption"
    mode: restart
    trigger:
      - id: start
        platform: state
        entity_id: script.irrigation_run
        to: "on"
      - id: end
        platform: state
        entity_id: script.irrigation_run
        to: "off"

    variables:
      selected_switch: "{{ states('input_select.irrigation_relay_entity') }}"
      fallback_power: >
        {% if selected_switch not in ['unknown','unavailable',''] %}
          {{ 'sensor.' ~ selected_switch.split('.')[1] ~ '_power' }}
        {% else %} {{ None }} {% endif %}
      power_entity: "{{ fallback_power }}"
      min_power: "{{ states('input_number.irrigation_relais1_power_min') | float(0) }}"
      max_power: "{{ states('input_number.irrigation_relais1_power_max') | float(0) }}"

    action:
      - choose:
          - conditions: "{{ trigger.id == 'start' }}"
            sequence:
              - wait_template: >
                  {% set st = states(power_entity) %}
                  {{ power_entity and st not in ['unknown','unavailable',''] and (st | float(0)) > 0 }}
                timeout: "00:00:30"
                continue_on_timeout: true
              - condition: template
                value_template: >
                  {% set st = states(power_entity) %}
                  {{ power_entity and st not in ['unknown','unavailable',''] }}
              - choose:
                  - conditions: "{{ (states(power_entity) | float(0)) <= min_power }}"
                    sequence:
                      - service: persistent_notification.create
                        data:
                          title: "{{ 'Power consumption ' ~ selected_switch ~ ' too low' }}"
                          message: >
                            Measured power ({{ states(power_entity) | float }} W)
                            is ≤ undercurrent threshold ({{ min_power }} W).
              - choose:
                  - conditions: "{{ (states(power_entity) | float(0)) >= max_power }}"
                    sequence:
                      - service: persistent_notification.create
                        data:
                          title: "{{ 'Power consumption ' ~ selected_switch ~ ' too high' }}"
                          message: >
                            Measured power ({{ states(power_entity) | float }} W)
                            exceeds over-current threshold ({{ max_power }} W).
          - conditions: "{{ trigger.id == 'end' }}"
            sequence:
              - delay: "00:00:02"
              - condition: template
                value_template: >
                  {% set st = states(power_entity) %}
                  {{ power_entity and st not in ['unknown','unavailable',''] and (st | float(0)) > 0 }}
              - service: persistent_notification.create
                data:
                  title: "{{ 'Power consumption ' ~ selected_switch ~ ' too high' }}"
                  message: >
                    Power after script end is {{ states(power_entity) | float }} W (should be 0 W).

  - id: irrigation_switch_unavailable_alert
    alias: "Irrigation – Alert if relay switch is unavailable"
    mode: single
    trigger:
      # Fire if the relay turns unavailable for at least 5 minutes
      - platform: state
        entity_id: switch.irrigation_relais1
        to: "unavailable"
        for: "00:05:00"
      # Also check on startup to catch existing issues
      - platform: homeassistant
        event: start
    condition: []
    action:
      - service: persistent_notification.create
        data:
          # Use a stable notification_id to avoid duplicates
          notification_id: irrigation_switch_unavailable
          title: "Irrigation relay not available"
          message: >
            The entity 'switch.irrigation_relais1' is unavailable.
            Please verify the device connection or entity registry.

  - id: gw3000a_radiation_stale_alert
    alias: "GW3000A – Alert if solar radiation is unavailable or stale (daytime only)"
    mode: single
    trigger:
      # Periodic health check every 30 minutes
      - platform: time_pattern
        minutes: "/30"
      # Also verify on HA startup
      - platform: homeassistant
        event: start

    variables:
      # Current state as string and last update timestamp in seconds
      rad_state: "{{ states('sensor.gw3000a_solar_radiation') }}"
      last_upd: "{{ as_timestamp(states.sensor.gw3000a_solar_radiation.last_updated, 0) }}"
      age_sec: "{{ (as_timestamp(now()) - last_upd) if last_upd > 0 else 1e12 }}"

    condition:
      # Trigger the alert only in the day
      - condition: sun
        after: sunrise
      - condition: sun
        before: sunset

      # if sensor ist unavailable or unknown
      - condition: template
        value_template: >
          {{ rad_state in ['unavailable','unknown',''] or age_sec > 2*60*60 }}

    action:
      - service: persistent_notification.create
        data:
          notification_id: gw3000a_radiation_stale
          title: "Solar radiation data missing or outdated"
          message: >
            The entity 'sensor.gw3000a_solar_radiation' is
            {{ 'unavailable/unknown' if rad_state in ['unavailable','unknown',''] else 'stale' }}.
            Age: {{ (age_sec/60) | round(0) }} minutes.
            Please check the GW3000A station and network connectivity.

  - id: gw3000a_wh65_battery_low_alert
    alias: "GW3000A WH65 – Alert on LOW battery"
    mode: single

    trigger:
      # Fire when battery changes from normal (off) to low (on)
      - platform: state
        entity_id: binary_sensor.gw3000a_wh65_battery
        from: "off"
        to: "on"
      # Also check on Home Assistant startup in case it's already low
      - platform: homeassistant
        event: start

    condition:
      # Ensure we only alert if it is actually low at evaluation time
      - condition: state
        entity_id: binary_sensor.gw3000a_wh65_battery
        state: "on"

    action:
      - service: persistent_notification.create
        data:
          notification_id: gw3000a_wh65_battery_low
          title: "WH65 battery low"
          message: >
            The entity 'binary_sensor.gw3000a_wh65_battery' reports LOW (state: on).
            Please check/replace the WH65 batteries and verify the station.